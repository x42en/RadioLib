<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RadioLib: E07_400MM Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">RadioLib
   </div>
   <div id="projectbrief">Universal wireless communication library for Arduino</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('class_e07__400_m_m.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_e07__400_m_m-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">E07_400MM Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>E07-400MM class extending RadioLib <a class="el" href="class_c_c1101.html" title="Control class for CC1101 module.">CC1101</a>.  
 <a href="class_e07__400_m_m.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_e07400_m_m_8h_source.html">E07400MM.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for E07_400MM:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_e07__400_m_m.png" usemap="#E07_5F400MM_map" alt=""/>
  <map id="E07_5F400MM_map" name="E07_5F400MM_map">
<area href="class_c_c1101.html" title="Control class for CC1101 module." alt="CC1101" shape="rect" coords="0,56,93,80"/>
<area href="class_physical_layer.html" title="Provides common interface for protocols that run on LoRa/FSK modules, such as RTTY or LoRaWAN...." alt="PhysicalLayer" shape="rect" coords="0,0,93,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aee915093d1eda0bbbedac6a4d9cd0aad" id="r_aee915093d1eda0bbbedac6a4d9cd0aad"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e07__400_m_m.html#aee915093d1eda0bbbedac6a4d9cd0aad">E07_400MM</a> (<a class="el" href="class_module.html">Module</a> *module)</td></tr>
<tr class="memdesc:aee915093d1eda0bbbedac6a4d9cd0aad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <br /></td></tr>
<tr class="separator:aee915093d1eda0bbbedac6a4d9cd0aad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6bcf25c3563acf901616028c7f148c4" id="r_ac6bcf25c3563acf901616028c7f148c4"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e07__400_m_m.html#ac6bcf25c3563acf901616028c7f148c4">getRSSI</a> () override</td></tr>
<tr class="memdesc:ac6bcf25c3563acf901616028c7f148c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get RSSI of last received packet or current RSSI level.  <br /></td></tr>
<tr class="separator:ac6bcf25c3563acf901616028c7f148c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a646aca8d01553e356c0e127c98bc6040" id="r_a646aca8d01553e356c0e127c98bc6040"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e07__400_m_m.html#a646aca8d01553e356c0e127c98bc6040">getPacketLength</a> (bool update=true) override</td></tr>
<tr class="memdesc:a646aca8d01553e356c0e127c98bc6040"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get packet length from FIFO.  <br /></td></tr>
<tr class="separator:a646aca8d01553e356c0e127c98bc6040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98ea3037c9f5ee73dae8cd6b6f4cd5e5" id="r_a98ea3037c9f5ee73dae8cd6b6f4cd5e5"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e07__400_m_m.html#a98ea3037c9f5ee73dae8cd6b6f4cd5e5">readData</a> (uint8_t *data, size_t len) override</td></tr>
<tr class="memdesc:a98ea3037c9f5ee73dae8cd6b6f4cd5e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read received packet data.  <br /></td></tr>
<tr class="separator:a98ea3037c9f5ee73dae8cd6b6f4cd5e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26d97adc5d08ee1391b81fe0f18a8e68" id="r_a26d97adc5d08ee1391b81fe0f18a8e68"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e07__400_m_m.html#a26d97adc5d08ee1391b81fe0f18a8e68">scanRSSI</a> (float *rssi_values, size_t num_points, float center_freq, float step_khz, uint16_t dwell_time_us=3000)</td></tr>
<tr class="memdesc:a26d97adc5d08ee1391b81fe0f18a8e68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform optimized RSSI spectrum scan.  <br /></td></tr>
<tr class="separator:a26d97adc5d08ee1391b81fe0f18a8e68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_c_c1101"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_c_c1101')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_c_c1101.html">CC1101</a></td></tr>
<tr class="memitem:a6807e4254c4b55fa8d393b2bf8f2db3e inherit pub_methods_class_c_c1101" id="r_a6807e4254c4b55fa8d393b2bf8f2db3e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#a6807e4254c4b55fa8d393b2bf8f2db3e">CC1101</a> (<a class="el" href="class_module.html">Module</a> *module)</td></tr>
<tr class="memdesc:a6807e4254c4b55fa8d393b2bf8f2db3e inherit pub_methods_class_c_c1101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <br /></td></tr>
<tr class="separator:a6807e4254c4b55fa8d393b2bf8f2db3e inherit pub_methods_class_c_c1101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad86f23bb3d113d20f6238a671f18b565 inherit pub_methods_class_c_c1101" id="r_ad86f23bb3d113d20f6238a671f18b565"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#ad86f23bb3d113d20f6238a671f18b565">begin</a> (float freq=RADIOLIB_CC1101_DEFAULT_FREQ, float br=RADIOLIB_CC1101_DEFAULT_BR, float freqDev=RADIOLIB_CC1101_DEFAULT_FREQDEV, float rxBw=RADIOLIB_CC1101_DEFAULT_RXBW, int8_t pwr=RADIOLIB_CC1101_DEFAULT_POWER, uint8_t preambleLength=RADIOLIB_CC1101_DEFAULT_PREAMBLELEN)</td></tr>
<tr class="memdesc:ad86f23bb3d113d20f6238a671f18b565 inherit pub_methods_class_c_c1101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization method.  <br /></td></tr>
<tr class="separator:ad86f23bb3d113d20f6238a671f18b565 inherit pub_methods_class_c_c1101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afff1ff2e763a3ad598bdae535595db63 inherit pub_methods_class_c_c1101" id="r_afff1ff2e763a3ad598bdae535595db63"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#afff1ff2e763a3ad598bdae535595db63">beginFSK4</a> (float freq=RADIOLIB_CC1101_DEFAULT_FREQ, float br=RADIOLIB_CC1101_DEFAULT_BR, float freqDev=RADIOLIB_CC1101_DEFAULT_FREQDEV, float rxBw=RADIOLIB_CC1101_DEFAULT_RXBW, int8_t pwr=RADIOLIB_CC1101_DEFAULT_POWER, uint8_t preambleLength=RADIOLIB_CC1101_DEFAULT_PREAMBLELEN)</td></tr>
<tr class="memdesc:afff1ff2e763a3ad598bdae535595db63 inherit pub_methods_class_c_c1101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization method for 4-FSK modulation.  <br /></td></tr>
<tr class="separator:afff1ff2e763a3ad598bdae535595db63 inherit pub_methods_class_c_c1101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fc87275c6f5d7f6927ca51a175eba21 inherit pub_methods_class_c_c1101" id="r_a1fc87275c6f5d7f6927ca51a175eba21"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>reset</b> ()</td></tr>
<tr class="memdesc:a1fc87275c6f5d7f6927ca51a175eba21 inherit pub_methods_class_c_c1101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset method - resets the chip using manual reset sequence (without RESET pin). <br /></td></tr>
<tr class="separator:a1fc87275c6f5d7f6927ca51a175eba21 inherit pub_methods_class_c_c1101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5086eb8a27aa842e94d1df54f385c39b inherit pub_methods_class_c_c1101" id="r_a5086eb8a27aa842e94d1df54f385c39b"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#a5086eb8a27aa842e94d1df54f385c39b">transmit</a> (const uint8_t *data, size_t len, uint8_t addr=0) override</td></tr>
<tr class="memdesc:a5086eb8a27aa842e94d1df54f385c39b inherit pub_methods_class_c_c1101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocking binary transmit method. Overloads for string-based transmissions are implemented in <a class="el" href="class_physical_layer.html" title="Provides common interface for protocols that run on LoRa/FSK modules, such as RTTY or LoRaWAN....">PhysicalLayer</a>.  <br /></td></tr>
<tr class="separator:a5086eb8a27aa842e94d1df54f385c39b inherit pub_methods_class_c_c1101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a7e12ef1eb2aaf9a5f39eeaa114e9f2 inherit pub_methods_class_c_c1101" id="r_a4a7e12ef1eb2aaf9a5f39eeaa114e9f2"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#a4a7e12ef1eb2aaf9a5f39eeaa114e9f2">receive</a> (uint8_t *data, size_t len, <a class="el" href="group__typedefs.html#ga210f31dd2bff7fb80563275648a5bbbd">RadioLibTime_t</a> timeout=0) override</td></tr>
<tr class="memdesc:a4a7e12ef1eb2aaf9a5f39eeaa114e9f2 inherit pub_methods_class_c_c1101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocking binary receive method. Overloads for string-based transmissions are implemented in <a class="el" href="class_physical_layer.html" title="Provides common interface for protocols that run on LoRa/FSK modules, such as RTTY or LoRaWAN....">PhysicalLayer</a>.  <br /></td></tr>
<tr class="separator:a4a7e12ef1eb2aaf9a5f39eeaa114e9f2 inherit pub_methods_class_c_c1101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7612bf81e48086004c62548de2682266 inherit pub_methods_class_c_c1101" id="r_a7612bf81e48086004c62548de2682266"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#a7612bf81e48086004c62548de2682266">standby</a> () override</td></tr>
<tr class="memdesc:a7612bf81e48086004c62548de2682266 inherit pub_methods_class_c_c1101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the module to standby mode.  <br /></td></tr>
<tr class="separator:a7612bf81e48086004c62548de2682266 inherit pub_methods_class_c_c1101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af374ad0ecd820a01baef7d177a30132a inherit pub_methods_class_c_c1101" id="r_af374ad0ecd820a01baef7d177a30132a"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#af374ad0ecd820a01baef7d177a30132a">standby</a> (uint8_t mode) override</td></tr>
<tr class="memdesc:af374ad0ecd820a01baef7d177a30132a inherit pub_methods_class_c_c1101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the module to standby.  <br /></td></tr>
<tr class="separator:af374ad0ecd820a01baef7d177a30132a inherit pub_methods_class_c_c1101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ead6224d4378274df465f779199bc92 inherit pub_methods_class_c_c1101" id="r_a0ead6224d4378274df465f779199bc92"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#a0ead6224d4378274df465f779199bc92">sleep</a> () override</td></tr>
<tr class="memdesc:a0ead6224d4378274df465f779199bc92 inherit pub_methods_class_c_c1101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the module to sleep mode.  <br /></td></tr>
<tr class="separator:a0ead6224d4378274df465f779199bc92 inherit pub_methods_class_c_c1101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a240eef8fa7d838d76f3c11086dc50e46 inherit pub_methods_class_c_c1101" id="r_a240eef8fa7d838d76f3c11086dc50e46"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#a240eef8fa7d838d76f3c11086dc50e46">transmitDirect</a> (uint32_t frf=0) override</td></tr>
<tr class="memdesc:a240eef8fa7d838d76f3c11086dc50e46 inherit pub_methods_class_c_c1101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts synchronous direct mode transmission.  <br /></td></tr>
<tr class="separator:a240eef8fa7d838d76f3c11086dc50e46 inherit pub_methods_class_c_c1101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab053c185330519d58f364790108d29ac inherit pub_methods_class_c_c1101" id="r_ab053c185330519d58f364790108d29ac"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#ab053c185330519d58f364790108d29ac">receiveDirect</a> () override</td></tr>
<tr class="memdesc:ab053c185330519d58f364790108d29ac inherit pub_methods_class_c_c1101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts synchronous direct mode reception.  <br /></td></tr>
<tr class="separator:ab053c185330519d58f364790108d29ac inherit pub_methods_class_c_c1101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef7c152858537a40e71cf133962cb893 inherit pub_methods_class_c_c1101" id="r_aef7c152858537a40e71cf133962cb893"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#aef7c152858537a40e71cf133962cb893">transmitDirectAsync</a> (uint32_t frf=0)</td></tr>
<tr class="memdesc:aef7c152858537a40e71cf133962cb893 inherit pub_methods_class_c_c1101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts asynchronous direct mode transmission.  <br /></td></tr>
<tr class="separator:aef7c152858537a40e71cf133962cb893 inherit pub_methods_class_c_c1101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ec1ff1312d2caaae7e3e0389268fca2 inherit pub_methods_class_c_c1101" id="r_a9ec1ff1312d2caaae7e3e0389268fca2"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#a9ec1ff1312d2caaae7e3e0389268fca2">receiveDirectAsync</a> ()</td></tr>
<tr class="memdesc:a9ec1ff1312d2caaae7e3e0389268fca2 inherit pub_methods_class_c_c1101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts asynchronous direct mode reception.  <br /></td></tr>
<tr class="separator:a9ec1ff1312d2caaae7e3e0389268fca2 inherit pub_methods_class_c_c1101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38f6978c757b0dd73e3ef98164a735a2 inherit pub_methods_class_c_c1101" id="r_a38f6978c757b0dd73e3ef98164a735a2"><td class="memItemLeft" align="right" valign="top">
int16_t&#160;</td><td class="memItemRight" valign="bottom"><b>packetMode</b> ()</td></tr>
<tr class="memdesc:a38f6978c757b0dd73e3ef98164a735a2 inherit pub_methods_class_c_c1101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops direct mode. It is required to call this method to switch from direct transmissions to packet-based transmissions. <br /></td></tr>
<tr class="separator:a38f6978c757b0dd73e3ef98164a735a2 inherit pub_methods_class_c_c1101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bee13612cf4da067faeb57d18ee2eb7 inherit pub_methods_class_c_c1101" id="r_a9bee13612cf4da067faeb57d18ee2eb7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#a9bee13612cf4da067faeb57d18ee2eb7">setGdo0Action</a> (void(*func)(void), uint32_t dir)</td></tr>
<tr class="memdesc:a9bee13612cf4da067faeb57d18ee2eb7 inherit pub_methods_class_c_c1101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets interrupt service routine to call when GDO0 activates.  <br /></td></tr>
<tr class="separator:a9bee13612cf4da067faeb57d18ee2eb7 inherit pub_methods_class_c_c1101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5e6b3745f80cf61e1ced33303311df8 inherit pub_methods_class_c_c1101" id="r_ab5e6b3745f80cf61e1ced33303311df8"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>clearGdo0Action</b> ()</td></tr>
<tr class="memdesc:ab5e6b3745f80cf61e1ced33303311df8 inherit pub_methods_class_c_c1101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears interrupt service routine to call when GDO0 activates. <br /></td></tr>
<tr class="separator:ab5e6b3745f80cf61e1ced33303311df8 inherit pub_methods_class_c_c1101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad71efbe54590e4431f3286ab99536fe9 inherit pub_methods_class_c_c1101" id="r_ad71efbe54590e4431f3286ab99536fe9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#ad71efbe54590e4431f3286ab99536fe9">setGdo2Action</a> (void(*func)(void), uint32_t dir)</td></tr>
<tr class="memdesc:ad71efbe54590e4431f3286ab99536fe9 inherit pub_methods_class_c_c1101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets interrupt service routine to call when GDO2 activates.  <br /></td></tr>
<tr class="separator:ad71efbe54590e4431f3286ab99536fe9 inherit pub_methods_class_c_c1101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7a8b1fe7d08dc6db20cf1569b0d37b4 inherit pub_methods_class_c_c1101" id="r_ac7a8b1fe7d08dc6db20cf1569b0d37b4"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>clearGdo2Action</b> ()</td></tr>
<tr class="memdesc:ac7a8b1fe7d08dc6db20cf1569b0d37b4 inherit pub_methods_class_c_c1101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears interrupt service routine to call when GDO0 activates. <br /></td></tr>
<tr class="separator:ac7a8b1fe7d08dc6db20cf1569b0d37b4 inherit pub_methods_class_c_c1101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29a16e8ed85432c6fae8d9e45399de6e inherit pub_methods_class_c_c1101" id="r_a29a16e8ed85432c6fae8d9e45399de6e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#a29a16e8ed85432c6fae8d9e45399de6e">setPacketReceivedAction</a> (void(*func)(void)) override</td></tr>
<tr class="memdesc:a29a16e8ed85432c6fae8d9e45399de6e inherit pub_methods_class_c_c1101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets interrupt service routine to call when a packet is received.  <br /></td></tr>
<tr class="separator:a29a16e8ed85432c6fae8d9e45399de6e inherit pub_methods_class_c_c1101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0221c4fe494a590cc9714e4752675d61 inherit pub_methods_class_c_c1101" id="r_a0221c4fe494a590cc9714e4752675d61"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#a0221c4fe494a590cc9714e4752675d61">clearPacketReceivedAction</a> () override</td></tr>
<tr class="memdesc:a0221c4fe494a590cc9714e4752675d61 inherit pub_methods_class_c_c1101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears interrupt service routine to call when a packet is received.  <br /></td></tr>
<tr class="separator:a0221c4fe494a590cc9714e4752675d61 inherit pub_methods_class_c_c1101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a336999da23e554073a9fa628131883f5 inherit pub_methods_class_c_c1101" id="r_a336999da23e554073a9fa628131883f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#a336999da23e554073a9fa628131883f5">setPacketSentAction</a> (void(*func)(void)) override</td></tr>
<tr class="memdesc:a336999da23e554073a9fa628131883f5 inherit pub_methods_class_c_c1101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets interrupt service routine to call when a packet is sent.  <br /></td></tr>
<tr class="separator:a336999da23e554073a9fa628131883f5 inherit pub_methods_class_c_c1101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2791ebc7fe71626407278de5852b492f inherit pub_methods_class_c_c1101" id="r_a2791ebc7fe71626407278de5852b492f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#a2791ebc7fe71626407278de5852b492f">clearPacketSentAction</a> () override</td></tr>
<tr class="memdesc:a2791ebc7fe71626407278de5852b492f inherit pub_methods_class_c_c1101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears interrupt service routine to call when a packet is sent.  <br /></td></tr>
<tr class="separator:a2791ebc7fe71626407278de5852b492f inherit pub_methods_class_c_c1101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ff7e4066d189482c142e05384a38df0 inherit pub_methods_class_c_c1101" id="r_a6ff7e4066d189482c142e05384a38df0"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#a6ff7e4066d189482c142e05384a38df0">startTransmit</a> (const uint8_t *data, size_t len, uint8_t addr=0) override</td></tr>
<tr class="memdesc:a6ff7e4066d189482c142e05384a38df0 inherit pub_methods_class_c_c1101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt-driven binary transmit method for packets less than 64 bytes. Method blocks for packets longer than 64 bytes up to a 255 byte limit, until the last bytes are placed in the FIFO. Some limitations and issues apply; see discussion: <a href="https://github.com/jgromes/RadioLib/discussions/1138">https://github.com/jgromes/RadioLib/discussions/1138</a> Overloads for string-based transmissions are implemented in <a class="el" href="class_physical_layer.html" title="Provides common interface for protocols that run on LoRa/FSK modules, such as RTTY or LoRaWAN....">PhysicalLayer</a>.  <br /></td></tr>
<tr class="separator:a6ff7e4066d189482c142e05384a38df0 inherit pub_methods_class_c_c1101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af70ea860154cd6d2b2e2a6962e161c8f inherit pub_methods_class_c_c1101" id="r_af70ea860154cd6d2b2e2a6962e161c8f"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#af70ea860154cd6d2b2e2a6962e161c8f">finishTransmit</a> () override</td></tr>
<tr class="memdesc:af70ea860154cd6d2b2e2a6962e161c8f inherit pub_methods_class_c_c1101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clean up after transmission is done.  <br /></td></tr>
<tr class="separator:af70ea860154cd6d2b2e2a6962e161c8f inherit pub_methods_class_c_c1101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae71e947abf6a07b194c6c6d64fd3eb19 inherit pub_methods_class_c_c1101" id="r_ae71e947abf6a07b194c6c6d64fd3eb19"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#ae71e947abf6a07b194c6c6d64fd3eb19">startReceive</a> () override</td></tr>
<tr class="memdesc:ae71e947abf6a07b194c6c6d64fd3eb19 inherit pub_methods_class_c_c1101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt-driven receive method. GDO0 will be activated when full packet is received.  <br /></td></tr>
<tr class="separator:ae71e947abf6a07b194c6c6d64fd3eb19 inherit pub_methods_class_c_c1101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf153c8fcf2a0d60439426b03692642e inherit pub_methods_class_c_c1101" id="r_abf153c8fcf2a0d60439426b03692642e"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#abf153c8fcf2a0d60439426b03692642e">startReceive</a> (uint32_t timeout, uint32_t irqFlags, uint32_t irqMask, size_t len) override</td></tr>
<tr class="memdesc:abf153c8fcf2a0d60439426b03692642e inherit pub_methods_class_c_c1101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt-driven receive method, implemented for compatibility with <a class="el" href="class_physical_layer.html" title="Provides common interface for protocols that run on LoRa/FSK modules, such as RTTY or LoRaWAN....">PhysicalLayer</a>.  <br /></td></tr>
<tr class="separator:abf153c8fcf2a0d60439426b03692642e inherit pub_methods_class_c_c1101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebd7dac7d846ff25a86b5a3f6e196a6b inherit pub_methods_class_c_c1101" id="r_aebd7dac7d846ff25a86b5a3f6e196a6b"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#aebd7dac7d846ff25a86b5a3f6e196a6b">finishReceive</a> () override</td></tr>
<tr class="memdesc:aebd7dac7d846ff25a86b5a3f6e196a6b inherit pub_methods_class_c_c1101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clean up after reception is done.  <br /></td></tr>
<tr class="separator:aebd7dac7d846ff25a86b5a3f6e196a6b inherit pub_methods_class_c_c1101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad428d7e6fc9ac119101bb0716fa80bee inherit pub_methods_class_c_c1101" id="r_ad428d7e6fc9ac119101bb0716fa80bee"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#ad428d7e6fc9ac119101bb0716fa80bee">setFrequency</a> (float freq) override</td></tr>
<tr class="memdesc:ad428d7e6fc9ac119101bb0716fa80bee inherit pub_methods_class_c_c1101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets carrier frequency. Allowed values are in bands 300.0 to 348.0 MHz, 387.0 to 464.0 MHz and 779.0 to 928.0 MHz.  <br /></td></tr>
<tr class="separator:ad428d7e6fc9ac119101bb0716fa80bee inherit pub_methods_class_c_c1101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fd22cdec29e1e34a92aa9854b90fdc9 inherit pub_methods_class_c_c1101" id="r_a6fd22cdec29e1e34a92aa9854b90fdc9"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#a6fd22cdec29e1e34a92aa9854b90fdc9">setBitRate</a> (float br) override</td></tr>
<tr class="memdesc:a6fd22cdec29e1e34a92aa9854b90fdc9 inherit pub_methods_class_c_c1101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets bit rate. Allowed values range from 0.025 to 600.0 kbps.  <br /></td></tr>
<tr class="separator:a6fd22cdec29e1e34a92aa9854b90fdc9 inherit pub_methods_class_c_c1101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc76af01dbc9171b3fdd7570624a4d4f inherit pub_methods_class_c_c1101" id="r_adc76af01dbc9171b3fdd7570624a4d4f"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#adc76af01dbc9171b3fdd7570624a4d4f">setBitRateTolerance</a> (uint8_t brt)</td></tr>
<tr class="memdesc:adc76af01dbc9171b3fdd7570624a4d4f inherit pub_methods_class_c_c1101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets bit rate tolerance in BSCFG register. Allowed values are 0:(0%), 1(3,125%), 2:(6,25%) and 3:(12,5%).  <br /></td></tr>
<tr class="separator:adc76af01dbc9171b3fdd7570624a4d4f inherit pub_methods_class_c_c1101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a381d0059d7a0ccd8a2f54d7d3376f9b6 inherit pub_methods_class_c_c1101" id="r_a381d0059d7a0ccd8a2f54d7d3376f9b6"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#a381d0059d7a0ccd8a2f54d7d3376f9b6">setRxBandwidth</a> (float rxBw)</td></tr>
<tr class="memdesc:a381d0059d7a0ccd8a2f54d7d3376f9b6 inherit pub_methods_class_c_c1101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets receiver bandwidth. Allowed values are 58, 68, 81, 102, 116, 135, 162, 203, 232, 270, 325, 406, 464, 541, 650 and 812 kHz.  <br /></td></tr>
<tr class="separator:a381d0059d7a0ccd8a2f54d7d3376f9b6 inherit pub_methods_class_c_c1101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a476adec156ae39974e70ef17b9af7db3 inherit pub_methods_class_c_c1101" id="r_a476adec156ae39974e70ef17b9af7db3"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#a476adec156ae39974e70ef17b9af7db3">autoSetRxBandwidth</a> ()</td></tr>
<tr class="memdesc:a476adec156ae39974e70ef17b9af7db3 inherit pub_methods_class_c_c1101"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculates and sets Rx bandwidth based on the freq, baud and freq uncertainty. Reimplement of atlas0fd00m's (RfCat) CalculatePktChanBw function. Modified for worse ppm with the <a class="el" href="class_c_c1101.html" title="Control class for CC1101 module.">CC1101</a>, and adjusted for the supportted <a class="el" href="class_c_c1101.html" title="Control class for CC1101 module.">CC1101</a> bw.  <br /></td></tr>
<tr class="separator:a476adec156ae39974e70ef17b9af7db3 inherit pub_methods_class_c_c1101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d69713b9f20c9de354c13c3167b18b3 inherit pub_methods_class_c_c1101" id="r_a0d69713b9f20c9de354c13c3167b18b3"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#a0d69713b9f20c9de354c13c3167b18b3">setFrequencyDeviation</a> (float freqDev) override</td></tr>
<tr class="memdesc:a0d69713b9f20c9de354c13c3167b18b3 inherit pub_methods_class_c_c1101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets frequency deviation. Allowed values range from 1.587 to 380.8 kHz.  <br /></td></tr>
<tr class="separator:a0d69713b9f20c9de354c13c3167b18b3 inherit pub_methods_class_c_c1101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe26fa310e973bf2b14750b9eae02124 inherit pub_methods_class_c_c1101" id="r_abe26fa310e973bf2b14750b9eae02124"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#abe26fa310e973bf2b14750b9eae02124">getFrequencyDeviation</a> (float *freqDev)</td></tr>
<tr class="memdesc:abe26fa310e973bf2b14750b9eae02124 inherit pub_methods_class_c_c1101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets frequency deviation.  <br /></td></tr>
<tr class="separator:abe26fa310e973bf2b14750b9eae02124 inherit pub_methods_class_c_c1101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d6dce30fc7da668975b6da663784cdf inherit pub_methods_class_c_c1101" id="r_a5d6dce30fc7da668975b6da663784cdf"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#a5d6dce30fc7da668975b6da663784cdf">setOutputPower</a> (int8_t pwr) override</td></tr>
<tr class="memdesc:a5d6dce30fc7da668975b6da663784cdf inherit pub_methods_class_c_c1101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets output power. Allowed values are -30, -20, -15, -10, 0, 5, 7 or 10 dBm.  <br /></td></tr>
<tr class="separator:a5d6dce30fc7da668975b6da663784cdf inherit pub_methods_class_c_c1101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab500e75fcf63f123eb3945925f361bd0 inherit pub_methods_class_c_c1101" id="r_ab500e75fcf63f123eb3945925f361bd0"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#ab500e75fcf63f123eb3945925f361bd0">checkOutputPower</a> (int8_t power, int8_t *clipped) override</td></tr>
<tr class="memdesc:ab500e75fcf63f123eb3945925f361bd0 inherit pub_methods_class_c_c1101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if output power is configurable. This method is needed for compatibility with <a class="el" href="class_physical_layer.html#a1784cb227d04b3f2846625fda6797536" title="Check if output power is configurable. Must be implemented in module class if the module supports it.">PhysicalLayer::checkOutputPower</a>.  <br /></td></tr>
<tr class="separator:ab500e75fcf63f123eb3945925f361bd0 inherit pub_methods_class_c_c1101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa86c74ed4339b70be6950e9f92be1d81 inherit pub_methods_class_c_c1101" id="r_aa86c74ed4339b70be6950e9f92be1d81"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#aa86c74ed4339b70be6950e9f92be1d81">checkOutputPower</a> (int8_t power, int8_t *clipped, uint8_t *raw)</td></tr>
<tr class="memdesc:aa86c74ed4339b70be6950e9f92be1d81 inherit pub_methods_class_c_c1101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if output power is configurable.  <br /></td></tr>
<tr class="separator:aa86c74ed4339b70be6950e9f92be1d81 inherit pub_methods_class_c_c1101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab299f0802f004c89ddab7c9192cd52ac inherit pub_methods_class_c_c1101" id="r_ab299f0802f004c89ddab7c9192cd52ac"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#ab299f0802f004c89ddab7c9192cd52ac">setSyncWord</a> (uint8_t *sync, size_t len) override</td></tr>
<tr class="memdesc:ab299f0802f004c89ddab7c9192cd52ac inherit pub_methods_class_c_c1101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set 1 or 2 bytes of sync word.  <br /></td></tr>
<tr class="separator:ab299f0802f004c89ddab7c9192cd52ac inherit pub_methods_class_c_c1101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a433f1a40b33be6c84d3665a1b4cd57d6 inherit pub_methods_class_c_c1101" id="r_a433f1a40b33be6c84d3665a1b4cd57d6"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#a433f1a40b33be6c84d3665a1b4cd57d6">setSyncWord</a> (uint8_t syncH, uint8_t syncL, uint8_t maxErrBits=0, bool requireCarrierSense=false)</td></tr>
<tr class="memdesc:a433f1a40b33be6c84d3665a1b4cd57d6 inherit pub_methods_class_c_c1101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets 16-bit sync word as a two byte value.  <br /></td></tr>
<tr class="separator:a433f1a40b33be6c84d3665a1b4cd57d6 inherit pub_methods_class_c_c1101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5345d819ea74f583e4e54f3496aa63eb inherit pub_methods_class_c_c1101" id="r_a5345d819ea74f583e4e54f3496aa63eb"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#a5345d819ea74f583e4e54f3496aa63eb">setSyncWord</a> (const uint8_t *syncWord, uint8_t len, uint8_t maxErrBits=0, bool requireCarrierSense=false)</td></tr>
<tr class="memdesc:a5345d819ea74f583e4e54f3496aa63eb inherit pub_methods_class_c_c1101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets 1 or 2 bytes of sync word.  <br /></td></tr>
<tr class="separator:a5345d819ea74f583e4e54f3496aa63eb inherit pub_methods_class_c_c1101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae535dc268518c51d03c12defbaebe93e inherit pub_methods_class_c_c1101" id="r_ae535dc268518c51d03c12defbaebe93e"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#ae535dc268518c51d03c12defbaebe93e">setPreambleLength</a> (size_t len) override</td></tr>
<tr class="memdesc:ae535dc268518c51d03c12defbaebe93e inherit pub_methods_class_c_c1101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets preamble length.  <br /></td></tr>
<tr class="separator:ae535dc268518c51d03c12defbaebe93e inherit pub_methods_class_c_c1101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae77c828c9c7cc12012fe011e8c4d3570 inherit pub_methods_class_c_c1101" id="r_ae77c828c9c7cc12012fe011e8c4d3570"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#ae77c828c9c7cc12012fe011e8c4d3570">setPreambleLength</a> (uint8_t preambleLength, uint8_t qualityThreshold)</td></tr>
<tr class="memdesc:ae77c828c9c7cc12012fe011e8c4d3570 inherit pub_methods_class_c_c1101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets preamble length.  <br /></td></tr>
<tr class="separator:ae77c828c9c7cc12012fe011e8c4d3570 inherit pub_methods_class_c_c1101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e62914790f132816134fc68c2bb5eb8 inherit pub_methods_class_c_c1101" id="r_a6e62914790f132816134fc68c2bb5eb8"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#a6e62914790f132816134fc68c2bb5eb8">setNodeAddress</a> (uint8_t nodeAddr, uint8_t numBroadcastAddrs=0)</td></tr>
<tr class="memdesc:a6e62914790f132816134fc68c2bb5eb8 inherit pub_methods_class_c_c1101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets node and broadcast addresses. Calling this method will also enable address filtering.  <br /></td></tr>
<tr class="separator:a6e62914790f132816134fc68c2bb5eb8 inherit pub_methods_class_c_c1101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aee5df428d30b9c80b8a8700609a883 inherit pub_methods_class_c_c1101" id="r_a9aee5df428d30b9c80b8a8700609a883"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#a9aee5df428d30b9c80b8a8700609a883">disableAddressFiltering</a> ()</td></tr>
<tr class="memdesc:a9aee5df428d30b9c80b8a8700609a883 inherit pub_methods_class_c_c1101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables address filtering. Calling this method will also erase previously set addresses.  <br /></td></tr>
<tr class="separator:a9aee5df428d30b9c80b8a8700609a883 inherit pub_methods_class_c_c1101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa64d1ad4789d3146b38d14437234756 inherit pub_methods_class_c_c1101" id="r_afa64d1ad4789d3146b38d14437234756"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#afa64d1ad4789d3146b38d14437234756">setOOK</a> (bool enableOOK)</td></tr>
<tr class="memdesc:afa64d1ad4789d3146b38d14437234756 inherit pub_methods_class_c_c1101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables/disables OOK modulation instead of FSK.  <br /></td></tr>
<tr class="separator:afa64d1ad4789d3146b38d14437234756 inherit pub_methods_class_c_c1101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59ca9e8956e308159949638bf327e5fb inherit pub_methods_class_c_c1101" id="r_a59ca9e8956e308159949638bf327e5fb"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#a59ca9e8956e308159949638bf327e5fb">getLQI</a> () const</td></tr>
<tr class="memdesc:a59ca9e8956e308159949638bf327e5fb inherit pub_methods_class_c_c1101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets LQI (Link Quality Indicator) of the last received packet.  <br /></td></tr>
<tr class="separator:a59ca9e8956e308159949638bf327e5fb inherit pub_methods_class_c_c1101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad25ad96cddf62273bffd601384d22275 inherit pub_methods_class_c_c1101" id="r_ad25ad96cddf62273bffd601384d22275"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#ad25ad96cddf62273bffd601384d22275">fixedPacketLengthMode</a> (uint8_t len=RADIOLIB_CC1101_MAX_PACKET_LENGTH)</td></tr>
<tr class="memdesc:ad25ad96cddf62273bffd601384d22275 inherit pub_methods_class_c_c1101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set modem in fixed packet length mode.  <br /></td></tr>
<tr class="separator:ad25ad96cddf62273bffd601384d22275 inherit pub_methods_class_c_c1101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50b9e73d2d82a4cd03841f465825b73f inherit pub_methods_class_c_c1101" id="r_a50b9e73d2d82a4cd03841f465825b73f"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#a50b9e73d2d82a4cd03841f465825b73f">variablePacketLengthMode</a> (uint8_t maxLen=RADIOLIB_CC1101_MAX_PACKET_LENGTH)</td></tr>
<tr class="memdesc:a50b9e73d2d82a4cd03841f465825b73f inherit pub_methods_class_c_c1101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set modem in variable packet length mode.  <br /></td></tr>
<tr class="separator:a50b9e73d2d82a4cd03841f465825b73f inherit pub_methods_class_c_c1101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fe55d0217bf5218865198ef8d6fdab4 inherit pub_methods_class_c_c1101" id="r_a6fe55d0217bf5218865198ef8d6fdab4"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#a6fe55d0217bf5218865198ef8d6fdab4">enableSyncWordFiltering</a> (uint8_t maxErrBits=0, bool requireCarrierSense=false)</td></tr>
<tr class="memdesc:a6fe55d0217bf5218865198ef8d6fdab4 inherit pub_methods_class_c_c1101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable sync word filtering and generation.  <br /></td></tr>
<tr class="separator:a6fe55d0217bf5218865198ef8d6fdab4 inherit pub_methods_class_c_c1101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f2dc4176b62a0636636088e31b8e85b inherit pub_methods_class_c_c1101" id="r_a4f2dc4176b62a0636636088e31b8e85b"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#a4f2dc4176b62a0636636088e31b8e85b">disableSyncWordFiltering</a> (bool requireCarrierSense=false)</td></tr>
<tr class="memdesc:a4f2dc4176b62a0636636088e31b8e85b inherit pub_methods_class_c_c1101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable preamble and sync word filtering and generation.  <br /></td></tr>
<tr class="separator:a4f2dc4176b62a0636636088e31b8e85b inherit pub_methods_class_c_c1101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60695681fc74a37f2a31a9638552e877 inherit pub_methods_class_c_c1101" id="r_a60695681fc74a37f2a31a9638552e877"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#a60695681fc74a37f2a31a9638552e877">setCrcFiltering</a> (bool enable=true)</td></tr>
<tr class="memdesc:a60695681fc74a37f2a31a9638552e877 inherit pub_methods_class_c_c1101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable CRC filtering and generation.  <br /></td></tr>
<tr class="separator:a60695681fc74a37f2a31a9638552e877 inherit pub_methods_class_c_c1101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1155543b27e46fa27aa4c9180da18bb inherit pub_methods_class_c_c1101" id="r_ac1155543b27e46fa27aa4c9180da18bb"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#ac1155543b27e46fa27aa4c9180da18bb">setPromiscuousMode</a> (bool enable=true, bool requireCarrierSense=false)</td></tr>
<tr class="memdesc:ac1155543b27e46fa27aa4c9180da18bb inherit pub_methods_class_c_c1101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set modem in "sniff" mode: no packet filtering (e.g., no preamble, sync word, address, CRC).  <br /></td></tr>
<tr class="separator:ac1155543b27e46fa27aa4c9180da18bb inherit pub_methods_class_c_c1101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeea78919ec14d940cda0f213e4fdced6 inherit pub_methods_class_c_c1101" id="r_aeea78919ec14d940cda0f213e4fdced6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#aeea78919ec14d940cda0f213e4fdced6">getPromiscuousMode</a> ()</td></tr>
<tr class="memdesc:aeea78919ec14d940cda0f213e4fdced6 inherit pub_methods_class_c_c1101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get whether the modem is in promiscuous mode: no packet filtering (e.g., no preamble, sync word, address, CRC).  <br /></td></tr>
<tr class="separator:aeea78919ec14d940cda0f213e4fdced6 inherit pub_methods_class_c_c1101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf96e77f25b7e256891601bef04f35a6 inherit pub_methods_class_c_c1101" id="r_adf96e77f25b7e256891601bef04f35a6"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#adf96e77f25b7e256891601bef04f35a6">setDataShaping</a> (uint8_t sh) override</td></tr>
<tr class="memdesc:adf96e77f25b7e256891601bef04f35a6 inherit pub_methods_class_c_c1101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets Gaussian filter bandwidth-time product that will be used for data shaping. Allowed value is RADIOLIB_SHAPING_0_5. Set to RADIOLIB_SHAPING_NONE to disable data shaping.  <br /></td></tr>
<tr class="separator:adf96e77f25b7e256891601bef04f35a6 inherit pub_methods_class_c_c1101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4b98eb6af33d006306bb7514ed216ea inherit pub_methods_class_c_c1101" id="r_ab4b98eb6af33d006306bb7514ed216ea"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#ab4b98eb6af33d006306bb7514ed216ea">setEncoding</a> (uint8_t encoding) override</td></tr>
<tr class="memdesc:ab4b98eb6af33d006306bb7514ed216ea inherit pub_methods_class_c_c1101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets transmission encoding. Allowed values are RADIOLIB_ENCODING_NRZ, RADIOLIB_ENCODING_MANCHESTER, and RADIOLIB_ENCODING_WHITENING. Note that encoding on <a class="el" href="class_c_c1101.html" title="Control class for CC1101 module.">CC1101</a> is applied to the entire stream including preamble, sync word, and CRC.  <br /></td></tr>
<tr class="separator:ab4b98eb6af33d006306bb7514ed216ea inherit pub_methods_class_c_c1101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ef45183690bb1879f106af079b01140 inherit pub_methods_class_c_c1101" id="r_a5ef45183690bb1879f106af079b01140"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#a5ef45183690bb1879f106af079b01140">setRfSwitchPins</a> (uint32_t rxEn, uint32_t txEn)</td></tr>
<tr class="memdesc:a5ef45183690bb1879f106af079b01140 inherit pub_methods_class_c_c1101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Some modules contain external RF switch controlled by pins. This function gives RadioLib control over those pins to automatically switch between various modes: When idle both pins will be LOW, during TX the <code>txEn</code> pin will be HIGH, during RX the <code>rxPin</code> will be HIGH.    <br /></td></tr>
<tr class="separator:a5ef45183690bb1879f106af079b01140 inherit pub_methods_class_c_c1101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b401995be4bc136063a035ce1820634 inherit pub_methods_class_c_c1101" id="r_a7b401995be4bc136063a035ce1820634"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#a7b401995be4bc136063a035ce1820634">setRfSwitchTable</a> (const uint32_t(&amp;pins)[<a class="el" href="class_module.html#a0c11551e12579bbabf57b19e12555b3c">Module::RFSWITCH_MAX_PINS</a>], const <a class="el" href="struct_module_1_1_rf_switch_mode__t.html">Module::RfSwitchMode_t</a> table[])</td></tr>
<tr class="memdesc:a7b401995be4bc136063a035ce1820634 inherit pub_methods_class_c_c1101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Some modules contain external RF switch controlled by pins. This function gives RadioLib control over those pins to automatically switch between various modes.    <br /></td></tr>
<tr class="separator:a7b401995be4bc136063a035ce1820634 inherit pub_methods_class_c_c1101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13cf332824479442cc20fc1c6972b092 inherit pub_methods_class_c_c1101" id="r_a13cf332824479442cc20fc1c6972b092"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#a13cf332824479442cc20fc1c6972b092">randomByte</a> () override</td></tr>
<tr class="memdesc:a13cf332824479442cc20fc1c6972b092 inherit pub_methods_class_c_c1101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get one truly random byte from RSSI noise.  <br /></td></tr>
<tr class="separator:a13cf332824479442cc20fc1c6972b092 inherit pub_methods_class_c_c1101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a4c6e622dffd2788d8ac52d708b0705 inherit pub_methods_class_c_c1101" id="r_a2a4c6e622dffd2788d8ac52d708b0705"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#a2a4c6e622dffd2788d8ac52d708b0705">getChipVersion</a> ()</td></tr>
<tr class="memdesc:a2a4c6e622dffd2788d8ac52d708b0705 inherit pub_methods_class_c_c1101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read version SPI register. Should return CC1101_VERSION_LEGACY (0x04) or CC1101_VERSION_CURRENT (0x14) if <a class="el" href="class_c_c1101.html" title="Control class for CC1101 module.">CC1101</a> is connected and working.  <br /></td></tr>
<tr class="separator:a2a4c6e622dffd2788d8ac52d708b0705 inherit pub_methods_class_c_c1101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24f4b059cc56238499c6117b88cd5505 inherit pub_methods_class_c_c1101" id="r_a24f4b059cc56238499c6117b88cd5505"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#a24f4b059cc56238499c6117b88cd5505">setDirectAction</a> (void(*func)(void)) override</td></tr>
<tr class="memdesc:a24f4b059cc56238499c6117b88cd5505 inherit pub_methods_class_c_c1101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set interrupt service routine function to call when data bit is receveid in direct mode.  <br /></td></tr>
<tr class="separator:a24f4b059cc56238499c6117b88cd5505 inherit pub_methods_class_c_c1101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11a92d885beefdf2db291301550a980c inherit pub_methods_class_c_c1101" id="r_a11a92d885beefdf2db291301550a980c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#a11a92d885beefdf2db291301550a980c">readBit</a> (uint32_t pin) override</td></tr>
<tr class="memdesc:a11a92d885beefdf2db291301550a980c inherit pub_methods_class_c_c1101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to read and process data bit in direct reception mode.  <br /></td></tr>
<tr class="separator:a11a92d885beefdf2db291301550a980c inherit pub_methods_class_c_c1101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a544bb8d7be9c0e1ff7f7103b30925862 inherit pub_methods_class_c_c1101" id="r_a544bb8d7be9c0e1ff7f7103b30925862"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#a544bb8d7be9c0e1ff7f7103b30925862">setDIOMapping</a> (uint32_t pin, uint32_t value) override</td></tr>
<tr class="memdesc:a544bb8d7be9c0e1ff7f7103b30925862 inherit pub_methods_class_c_c1101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure DIO pin mapping to get a given signal on a DIO pin (if available).  <br /></td></tr>
<tr class="separator:a544bb8d7be9c0e1ff7f7103b30925862 inherit pub_methods_class_c_c1101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae608fabef91defa1e33e6a6787c68ce8 inherit pub_methods_class_c_c1101" id="r_ae608fabef91defa1e33e6a6787c68ce8"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#ae608fabef91defa1e33e6a6787c68ce8">receive</a> (uint8_t *data, size_t len, <a class="el" href="group__typedefs.html#ga210f31dd2bff7fb80563275648a5bbbd">RadioLibTime_t</a> timeout=0)</td></tr>
<tr class="memdesc:ae608fabef91defa1e33e6a6787c68ce8 inherit pub_methods_class_c_c1101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary receive method. Must be implemented in module class.  <br /></td></tr>
<tr class="separator:ae608fabef91defa1e33e6a6787c68ce8 inherit pub_methods_class_c_c1101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a923654706eff5118ef6e84214e837f27 inherit pub_methods_class_c_c1101" id="r_a923654706eff5118ef6e84214e837f27"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#a923654706eff5118ef6e84214e837f27">startTransmit</a> (const char *str, uint8_t addr=0)</td></tr>
<tr class="memdesc:a923654706eff5118ef6e84214e837f27 inherit pub_methods_class_c_c1101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt-driven Arduino String transmit method. Unlike the standard transmit method, this one is non-blocking. Interrupt pin will be activated when transmission finishes.  <br /></td></tr>
<tr class="separator:a923654706eff5118ef6e84214e837f27 inherit pub_methods_class_c_c1101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af79757dbbd62e080c1bad2e608ab940c inherit pub_methods_class_c_c1101" id="r_af79757dbbd62e080c1bad2e608ab940c"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#af79757dbbd62e080c1bad2e608ab940c">startTransmit</a> (const uint8_t *data, size_t len, uint8_t addr=0)</td></tr>
<tr class="memdesc:af79757dbbd62e080c1bad2e608ab940c inherit pub_methods_class_c_c1101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt-driven binary transmit method.  <br /></td></tr>
<tr class="separator:af79757dbbd62e080c1bad2e608ab940c inherit pub_methods_class_c_c1101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a492b2d057dd803c3884fa1adc8e22534 inherit pub_methods_class_c_c1101" id="r_a492b2d057dd803c3884fa1adc8e22534"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#a492b2d057dd803c3884fa1adc8e22534">transmit</a> (const char *str, uint8_t addr=0)</td></tr>
<tr class="memdesc:a492b2d057dd803c3884fa1adc8e22534 inherit pub_methods_class_c_c1101"><td class="mdescLeft">&#160;</td><td class="mdescRight">C-string transmit method.  <br /></td></tr>
<tr class="separator:a492b2d057dd803c3884fa1adc8e22534 inherit pub_methods_class_c_c1101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada508497ee2e70170da3afe078e2fe0e inherit pub_methods_class_c_c1101" id="r_ada508497ee2e70170da3afe078e2fe0e"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#ada508497ee2e70170da3afe078e2fe0e">transmit</a> (const uint8_t *data, size_t len, uint8_t addr=0)</td></tr>
<tr class="memdesc:ada508497ee2e70170da3afe078e2fe0e inherit pub_methods_class_c_c1101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary transmit method. Must be implemented in module class.  <br /></td></tr>
<tr class="separator:ada508497ee2e70170da3afe078e2fe0e inherit pub_methods_class_c_c1101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_physical_layer"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_physical_layer')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_physical_layer.html">PhysicalLayer</a></td></tr>
<tr class="memitem:afc972a84153977d6ccd9e116b6181ad4 inherit pub_methods_class_physical_layer" id="r_afc972a84153977d6ccd9e116b6181ad4"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>PhysicalLayer</b> ()</td></tr>
<tr class="memdesc:afc972a84153977d6ccd9e116b6181ad4 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. <br /></td></tr>
<tr class="separator:afc972a84153977d6ccd9e116b6181ad4 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7af88f9f75c9778c29002c2b8238a239 inherit pub_methods_class_physical_layer" id="r_a7af88f9f75c9778c29002c2b8238a239"><td class="memItemLeft" align="right" valign="top">
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~PhysicalLayer</b> ()=default</td></tr>
<tr class="memdesc:a7af88f9f75c9778c29002c2b8238a239 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default destructor. <br /></td></tr>
<tr class="separator:a7af88f9f75c9778c29002c2b8238a239 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a492b2d057dd803c3884fa1adc8e22534 inherit pub_methods_class_physical_layer" id="r_a492b2d057dd803c3884fa1adc8e22534"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a492b2d057dd803c3884fa1adc8e22534">transmit</a> (const char *str, uint8_t addr=0)</td></tr>
<tr class="memdesc:a492b2d057dd803c3884fa1adc8e22534 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">C-string transmit method.  <br /></td></tr>
<tr class="separator:a492b2d057dd803c3884fa1adc8e22534 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a923654706eff5118ef6e84214e837f27 inherit pub_methods_class_physical_layer" id="r_a923654706eff5118ef6e84214e837f27"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a923654706eff5118ef6e84214e837f27">startTransmit</a> (const char *str, uint8_t addr=0)</td></tr>
<tr class="memdesc:a923654706eff5118ef6e84214e837f27 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt-driven Arduino String transmit method. Unlike the standard transmit method, this one is non-blocking. Interrupt pin will be activated when transmission finishes.  <br /></td></tr>
<tr class="separator:a923654706eff5118ef6e84214e837f27 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11b4c6d0bf3ae7b9ca04e9434180feab inherit pub_methods_class_physical_layer" id="r_a11b4c6d0bf3ae7b9ca04e9434180feab"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a11b4c6d0bf3ae7b9ca04e9434180feab">invertIQ</a> (bool enable)</td></tr>
<tr class="memdesc:a11b4c6d0bf3ae7b9ca04e9434180feab inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set IQ inversion. Must be implemented in module class if the module supports it.  <br /></td></tr>
<tr class="separator:a11b4c6d0bf3ae7b9ca04e9434180feab inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5f1e0c24d8bf878f2c9fe729b6e1610 inherit pub_methods_class_physical_layer" id="r_ac5f1e0c24d8bf878f2c9fe729b6e1610"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#ac5f1e0c24d8bf878f2c9fe729b6e1610">setDataRate</a> (<a class="el" href="union_data_rate__t.html">DataRate_t</a> dr, ModemType_t modem=RADIOLIB_MODEM_NONE)</td></tr>
<tr class="memdesc:ac5f1e0c24d8bf878f2c9fe729b6e1610 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set data rate. Must be implemented in module class if the module supports it.  <br /></td></tr>
<tr class="separator:ac5f1e0c24d8bf878f2c9fe729b6e1610 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c5c902d9f8ffe9866b7f178b14d34f6 inherit pub_methods_class_physical_layer" id="r_a9c5c902d9f8ffe9866b7f178b14d34f6"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a9c5c902d9f8ffe9866b7f178b14d34f6">checkDataRate</a> (<a class="el" href="union_data_rate__t.html">DataRate_t</a> dr, ModemType_t modem=RADIOLIB_MODEM_NONE)</td></tr>
<tr class="memdesc:a9c5c902d9f8ffe9866b7f178b14d34f6 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the data rate can be configured by this module. Must be implemented in module class if the module supports it.  <br /></td></tr>
<tr class="separator:a9c5c902d9f8ffe9866b7f178b14d34f6 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedddaf9460941b90e43e9005035faa0f inherit pub_methods_class_physical_layer" id="r_aedddaf9460941b90e43e9005035faa0f"><td class="memItemLeft" align="right" valign="top">virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#aedddaf9460941b90e43e9005035faa0f">getSNR</a> ()</td></tr>
<tr class="memdesc:aedddaf9460941b90e43e9005035faa0f inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets SNR (Signal to Noise Ratio) of the last received packet. Only available for LoRa modem.  <br /></td></tr>
<tr class="separator:aedddaf9460941b90e43e9005035faa0f inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1974cb6218782c557a673aeb4a99928 inherit pub_methods_class_physical_layer" id="r_ac1974cb6218782c557a673aeb4a99928"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__typedefs.html#ga210f31dd2bff7fb80563275648a5bbbd">RadioLibTime_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#ac1974cb6218782c557a673aeb4a99928">calculateTimeOnAir</a> (ModemType_t modem, <a class="el" href="union_data_rate__t.html">DataRate_t</a> dr, <a class="el" href="union_packet_config__t.html">PacketConfig_t</a> pc, size_t len)</td></tr>
<tr class="memdesc:ac1974cb6218782c557a673aeb4a99928 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the expected time-on-air for a given modem, data rate, packet configuration and payload size.  <br /></td></tr>
<tr class="separator:ac1974cb6218782c557a673aeb4a99928 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50e730a894f60b58034507ad7730dd3c inherit pub_methods_class_physical_layer" id="r_a50e730a894f60b58034507ad7730dd3c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__typedefs.html#ga210f31dd2bff7fb80563275648a5bbbd">RadioLibTime_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a50e730a894f60b58034507ad7730dd3c">getTimeOnAir</a> (size_t len)</td></tr>
<tr class="memdesc:a50e730a894f60b58034507ad7730dd3c inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get expected time-on-air for a given size of payload.  <br /></td></tr>
<tr class="separator:a50e730a894f60b58034507ad7730dd3c inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f8d12a90158864a8ebc471b0ec89dc9 inherit pub_methods_class_physical_layer" id="r_a7f8d12a90158864a8ebc471b0ec89dc9"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__typedefs.html#ga210f31dd2bff7fb80563275648a5bbbd">RadioLibTime_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a7f8d12a90158864a8ebc471b0ec89dc9">calculateRxTimeout</a> (<a class="el" href="group__typedefs.html#ga210f31dd2bff7fb80563275648a5bbbd">RadioLibTime_t</a> timeoutUs)</td></tr>
<tr class="memdesc:a7f8d12a90158864a8ebc471b0ec89dc9 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the timeout value for this specific module / series (in number of symbols or units of time).  <br /></td></tr>
<tr class="separator:a7f8d12a90158864a8ebc471b0ec89dc9 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae602ebd46d60da8670c9f353cef695d9 inherit pub_methods_class_physical_layer" id="r_ae602ebd46d60da8670c9f353cef695d9"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#ae602ebd46d60da8670c9f353cef695d9">getIrqMapped</a> (<a class="el" href="group__typedefs.html#gafaf66becf1112a55ba8ad7402b802b77">RadioLibIrqFlags_t</a> irq)</td></tr>
<tr class="memdesc:ae602ebd46d60da8670c9f353cef695d9 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert from radio-agnostic IRQ flags to radio-specific flags.  <br /></td></tr>
<tr class="separator:ae602ebd46d60da8670c9f353cef695d9 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c7dd4704e3df353265010710bd26e83 inherit pub_methods_class_physical_layer" id="r_a2c7dd4704e3df353265010710bd26e83"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a2c7dd4704e3df353265010710bd26e83">checkIrq</a> (RadioLibIrqType_t irq)</td></tr>
<tr class="memdesc:a2c7dd4704e3df353265010710bd26e83 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a specific IRQ bit is set (e.g. RxTimeout, CadDone).  <br /></td></tr>
<tr class="separator:a2c7dd4704e3df353265010710bd26e83 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8564f9834a0247e93e7620c23559ceb8 inherit pub_methods_class_physical_layer" id="r_a8564f9834a0247e93e7620c23559ceb8"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a8564f9834a0247e93e7620c23559ceb8">setIrq</a> (<a class="el" href="group__typedefs.html#gafaf66becf1112a55ba8ad7402b802b77">RadioLibIrqFlags_t</a> irq)</td></tr>
<tr class="memdesc:a8564f9834a0247e93e7620c23559ceb8 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set interrupt on specific IRQ bit(s) (e.g. RxTimeout, CadDone). Keep in mind that not all radio modules support all RADIOLIB_IRQ_ flags!  <br /></td></tr>
<tr class="separator:a8564f9834a0247e93e7620c23559ceb8 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9a7e739e39705a72ffa8b63ec09bb15 inherit pub_methods_class_physical_layer" id="r_af9a7e739e39705a72ffa8b63ec09bb15"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#af9a7e739e39705a72ffa8b63ec09bb15">clearIrq</a> (<a class="el" href="group__typedefs.html#gafaf66becf1112a55ba8ad7402b802b77">RadioLibIrqFlags_t</a> irq)</td></tr>
<tr class="memdesc:af9a7e739e39705a72ffa8b63ec09bb15 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear interrupt on a specific IRQ bit (e.g. RxTimeout, CadDone). Keep in mind that not all radio modules support all RADIOLIB_IRQ_ flags!  <br /></td></tr>
<tr class="separator:af9a7e739e39705a72ffa8b63ec09bb15 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1caeed34b2e2ff0355467507106a1a2 inherit pub_methods_class_physical_layer" id="r_af1caeed34b2e2ff0355467507106a1a2"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#af1caeed34b2e2ff0355467507106a1a2">getIrqFlags</a> ()</td></tr>
<tr class="memdesc:af1caeed34b2e2ff0355467507106a1a2 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read currently active IRQ flags. Must be implemented in module class.  <br /></td></tr>
<tr class="separator:af1caeed34b2e2ff0355467507106a1a2 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af88dcb54dc8e9a1edaf9f1c3e5ee2b74 inherit pub_methods_class_physical_layer" id="r_af88dcb54dc8e9a1edaf9f1c3e5ee2b74"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#af88dcb54dc8e9a1edaf9f1c3e5ee2b74">setIrqFlags</a> (uint32_t irq)</td></tr>
<tr class="memdesc:af88dcb54dc8e9a1edaf9f1c3e5ee2b74 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set interrupt on DIO1 to be sent on a specific IRQ bit (e.g. RxTimeout, CadDone). Must be implemented in module class.  <br /></td></tr>
<tr class="separator:af88dcb54dc8e9a1edaf9f1c3e5ee2b74 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac282bb78da4f4da4661dce191cbd6d87 inherit pub_methods_class_physical_layer" id="r_ac282bb78da4f4da4661dce191cbd6d87"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#ac282bb78da4f4da4661dce191cbd6d87">clearIrqFlags</a> (uint32_t irq)</td></tr>
<tr class="memdesc:ac282bb78da4f4da4661dce191cbd6d87 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear interrupt on a specific IRQ bit (e.g. RxTimeout, CadDone). Must be implemented in module class.  <br /></td></tr>
<tr class="separator:ac282bb78da4f4da4661dce191cbd6d87 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae30dfbb5445bb674898fc54f5f90b2f9 inherit pub_methods_class_physical_layer" id="r_ae30dfbb5445bb674898fc54f5f90b2f9"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#ae30dfbb5445bb674898fc54f5f90b2f9">startChannelScan</a> ()</td></tr>
<tr class="memdesc:ae30dfbb5445bb674898fc54f5f90b2f9 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt-driven channel activity detection method. Interrupt will be activated when packet is detected. Must be implemented in module class.  <br /></td></tr>
<tr class="separator:ae30dfbb5445bb674898fc54f5f90b2f9 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82a52062d9259c2c546d7bf8072b7a72 inherit pub_methods_class_physical_layer" id="r_a82a52062d9259c2c546d7bf8072b7a72"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a82a52062d9259c2c546d7bf8072b7a72">startChannelScan</a> (const <a class="el" href="union_channel_scan_config__t.html">ChannelScanConfig_t</a> &amp;config)</td></tr>
<tr class="memdesc:a82a52062d9259c2c546d7bf8072b7a72 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt-driven channel activity detection method. interrupt will be activated when packet is detected. Must be implemented in module class.  <br /></td></tr>
<tr class="separator:a82a52062d9259c2c546d7bf8072b7a72 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63979795a7b53557560bb95b65480906 inherit pub_methods_class_physical_layer" id="r_a63979795a7b53557560bb95b65480906"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a63979795a7b53557560bb95b65480906">getChannelScanResult</a> ()</td></tr>
<tr class="memdesc:a63979795a7b53557560bb95b65480906 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the channel scan result.  <br /></td></tr>
<tr class="separator:a63979795a7b53557560bb95b65480906 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd9e39cc745acbf084cfa0d3f4d10718 inherit pub_methods_class_physical_layer" id="r_abd9e39cc745acbf084cfa0d3f4d10718"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#abd9e39cc745acbf084cfa0d3f4d10718">scanChannel</a> ()</td></tr>
<tr class="memdesc:abd9e39cc745acbf084cfa0d3f4d10718 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the current communication channel is free or occupied. Performs CAD for LoRa modules, or RSSI measurement for FSK modules.  <br /></td></tr>
<tr class="separator:abd9e39cc745acbf084cfa0d3f4d10718 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af788cf83ceb0222cd0fa4a1323b9041b inherit pub_methods_class_physical_layer" id="r_af788cf83ceb0222cd0fa4a1323b9041b"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#af788cf83ceb0222cd0fa4a1323b9041b">scanChannel</a> (const <a class="el" href="union_channel_scan_config__t.html">ChannelScanConfig_t</a> &amp;config)</td></tr>
<tr class="memdesc:af788cf83ceb0222cd0fa4a1323b9041b inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the current communication channel is free or occupied. Performs CAD for LoRa modules, or RSSI measurement for FSK modules.  <br /></td></tr>
<tr class="separator:af788cf83ceb0222cd0fa4a1323b9041b inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd9171bd71aa80fb86113b612c42de53 inherit pub_methods_class_physical_layer" id="r_acd9171bd71aa80fb86113b612c42de53"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#acd9171bd71aa80fb86113b612c42de53">random</a> (int32_t max)</td></tr>
<tr class="memdesc:acd9171bd71aa80fb86113b612c42de53 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get truly random number in range 0 - max.  <br /></td></tr>
<tr class="separator:acd9171bd71aa80fb86113b612c42de53 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76113e10481743094a1cd0280692b0a9 inherit pub_methods_class_physical_layer" id="r_a76113e10481743094a1cd0280692b0a9"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a76113e10481743094a1cd0280692b0a9">random</a> (int32_t min, int32_t max)</td></tr>
<tr class="memdesc:a76113e10481743094a1cd0280692b0a9 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get truly random number in range min - max.  <br /></td></tr>
<tr class="separator:a76113e10481743094a1cd0280692b0a9 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88a10657bd2215a11a2331f937414b55 inherit pub_methods_class_physical_layer" id="r_a88a10657bd2215a11a2331f937414b55"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a88a10657bd2215a11a2331f937414b55">startDirect</a> ()</td></tr>
<tr class="memdesc:a88a10657bd2215a11a2331f937414b55 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure module parameters for direct modes. Must be called prior to "ham" modes like RTTY or AX.25. Only available in FSK mode.  <br /></td></tr>
<tr class="separator:a88a10657bd2215a11a2331f937414b55 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e378fe136a498ea485a9c10f5e15aab inherit pub_methods_class_physical_layer" id="r_a8e378fe136a498ea485a9c10f5e15aab"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a8e378fe136a498ea485a9c10f5e15aab">setDirectSyncWord</a> (uint32_t syncWord, uint8_t len)</td></tr>
<tr class="memdesc:a8e378fe136a498ea485a9c10f5e15aab inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set sync word to be used to determine start of packet in direct reception mode.  <br /></td></tr>
<tr class="separator:a8e378fe136a498ea485a9c10f5e15aab inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab57182d32646861ef0d865e2740d6b26 inherit pub_methods_class_physical_layer" id="r_ab57182d32646861ef0d865e2740d6b26"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#ab57182d32646861ef0d865e2740d6b26">available</a> ()</td></tr>
<tr class="memdesc:ab57182d32646861ef0d865e2740d6b26 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of direct mode bytes currently available in buffer.  <br /></td></tr>
<tr class="separator:ab57182d32646861ef0d865e2740d6b26 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a429796eb2e7ea86781a2e8ca42af43f3 inherit pub_methods_class_physical_layer" id="r_a429796eb2e7ea86781a2e8ca42af43f3"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>dropSync</b> ()</td></tr>
<tr class="memdesc:a429796eb2e7ea86781a2e8ca42af43f3 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forcefully drop synchronization. <br /></td></tr>
<tr class="separator:a429796eb2e7ea86781a2e8ca42af43f3 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d5b30493c8d7fcfb784e128362d596c inherit pub_methods_class_physical_layer" id="r_a4d5b30493c8d7fcfb784e128362d596c"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a4d5b30493c8d7fcfb784e128362d596c">read</a> (bool drop=true)</td></tr>
<tr class="memdesc:a4d5b30493c8d7fcfb784e128362d596c inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get data from direct mode buffer.  <br /></td></tr>
<tr class="separator:a4d5b30493c8d7fcfb784e128362d596c inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae11c191a7edf3116bf468b9153237260 inherit pub_methods_class_physical_layer" id="r_ae11c191a7edf3116bf468b9153237260"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#ae11c191a7edf3116bf468b9153237260">setChannelScanAction</a> (void(*func)(void))</td></tr>
<tr class="memdesc:ae11c191a7edf3116bf468b9153237260 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets interrupt service routine to call when a channel scan is finished.  <br /></td></tr>
<tr class="separator:ae11c191a7edf3116bf468b9153237260 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a169a4d04c5c50d3336e274d70930d9f6 inherit pub_methods_class_physical_layer" id="r_a169a4d04c5c50d3336e274d70930d9f6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a169a4d04c5c50d3336e274d70930d9f6">clearChannelScanAction</a> ()</td></tr>
<tr class="memdesc:a169a4d04c5c50d3336e274d70930d9f6 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears interrupt service routine to call when a channel scan is finished.  <br /></td></tr>
<tr class="separator:a169a4d04c5c50d3336e274d70930d9f6 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77415bf4ed34be18c92c0cf4b2de7149 inherit pub_methods_class_physical_layer" id="r_a77415bf4ed34be18c92c0cf4b2de7149"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a77415bf4ed34be18c92c0cf4b2de7149">setModem</a> (ModemType_t modem)</td></tr>
<tr class="memdesc:a77415bf4ed34be18c92c0cf4b2de7149 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set modem for the radio to use. Will perform full reset and reconfigure the radio using its default parameters.  <br /></td></tr>
<tr class="separator:a77415bf4ed34be18c92c0cf4b2de7149 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af061879bf694735297593c048d04a196 inherit pub_methods_class_physical_layer" id="r_af061879bf694735297593c048d04a196"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#af061879bf694735297593c048d04a196">getModem</a> (ModemType_t *modem)</td></tr>
<tr class="memdesc:af061879bf694735297593c048d04a196 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get modem currently in use by the radio.  <br /></td></tr>
<tr class="separator:af061879bf694735297593c048d04a196 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06fa3b844c6028a78e29b7dff58c7c79 inherit pub_methods_class_physical_layer" id="r_a06fa3b844c6028a78e29b7dff58c7c79"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a06fa3b844c6028a78e29b7dff58c7c79">stageMode</a> (RadioModeType_t mode, <a class="el" href="union_radio_mode_config__t.html">RadioModeConfig_t</a> *cfg)</td></tr>
<tr class="memdesc:a06fa3b844c6028a78e29b7dff58c7c79 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stage mode of the radio to be launched later using launchMode.  <br /></td></tr>
<tr class="separator:a06fa3b844c6028a78e29b7dff58c7c79 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c5977bc9f54f21665b022a99e6c87cc inherit pub_methods_class_physical_layer" id="r_a5c5977bc9f54f21665b022a99e6c87cc"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a5c5977bc9f54f21665b022a99e6c87cc">launchMode</a> ()</td></tr>
<tr class="memdesc:a5c5977bc9f54f21665b022a99e6c87cc inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Launch previously staged mode.  <br /></td></tr>
<tr class="separator:a5c5977bc9f54f21665b022a99e6c87cc inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_attribs_class_physical_layer"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_class_physical_layer')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="class_physical_layer.html">PhysicalLayer</a></td></tr>
<tr class="memitem:aa949616080a463a82bb6ad5075a9e16e inherit pub_attribs_class_physical_layer" id="r_aa949616080a463a82bb6ad5075a9e16e"><td class="memItemLeft" align="right" valign="top">
float&#160;</td><td class="memItemRight" valign="bottom"><b>freqStep</b></td></tr>
<tr class="memdesc:aa949616080a463a82bb6ad5075a9e16e inherit pub_attribs_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frequency step of the synthesizer in Hz. <br /></td></tr>
<tr class="separator:aa949616080a463a82bb6ad5075a9e16e inherit pub_attribs_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c04f8fba5eef96e59972004e8abc623 inherit pub_attribs_class_physical_layer" id="r_a1c04f8fba5eef96e59972004e8abc623"><td class="memItemLeft" align="right" valign="top">
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>maxPacketLength</b></td></tr>
<tr class="memdesc:a1c04f8fba5eef96e59972004e8abc623 inherit pub_attribs_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum length of packet that can be received by the module. <br /></td></tr>
<tr class="separator:a1c04f8fba5eef96e59972004e8abc623 inherit pub_attribs_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>E07-400MM class extending RadioLib <a class="el" href="class_c_c1101.html" title="Control class for CC1101 module.">CC1101</a>. </p>
<p>This class provides compatibility with the E07-400MM <a class="el" href="class_c_c1101.html" title="Control class for CC1101 module.">CC1101</a> clone by overriding methods that require BURST mode for register access. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aee915093d1eda0bbbedac6a4d9cd0aad" name="aee915093d1eda0bbbedac6a4d9cd0aad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee915093d1eda0bbbedac6a4d9cd0aad">&#9670;&#160;</a></span>E07_400MM()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">E07_400MM::E07_400MM </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>module</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">module</td><td>Pointer to <a class="el" href="class_module.html" title="Implements all common low-level methods to control the wireless module. Every module class contains o...">Module</a> instance (SPI wrapper) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a646aca8d01553e356c0e127c98bc6040" name="a646aca8d01553e356c0e127c98bc6040"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a646aca8d01553e356c0e127c98bc6040">&#9670;&#160;</a></span>getPacketLength()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t E07_400MM::getPacketLength </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>update</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get packet length from FIFO. </p>
<p>Overrides RadioLib's <a class="el" href="class_e07__400_m_m.html#a646aca8d01553e356c0e127c98bc6040" title="Get packet length from FIFO.">getPacketLength()</a> to use direct FIFO access with BURST mode. RadioLib's implementation uses SPIreadRegister() which doesn't work with FIFO.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">update</td><td>Update packet length from FIFO (default: true) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Packet length in bytes </dd></dl>

<p>Reimplemented from <a class="el" href="class_c_c1101.html#a122281f6a915b77ee9dafc9926e731a0">CC1101</a>.</p>

</div>
</div>
<a id="ac6bcf25c3563acf901616028c7f148c4" name="ac6bcf25c3563acf901616028c7f148c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6bcf25c3563acf901616028c7f148c4">&#9670;&#160;</a></span>getRSSI()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float E07_400MM::getRSSI </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get RSSI of last received packet or current RSSI level. </p>
<p>Overrides RadioLib's <a class="el" href="class_e07__400_m_m.html#ac6bcf25c3563acf901616028c7f148c4" title="Get RSSI of last received packet or current RSSI level.">getRSSI()</a> to use direct register access with BURST mode. This is critical for scanning as RadioLib caches RSSI values.</p>
<dl class="section return"><dt>Returns</dt><dd>RSSI in dBm </dd></dl>

<p>Reimplemented from <a class="el" href="class_c_c1101.html#ab80835be83e5a43010afe4e8185114eb">CC1101</a>.</p>

</div>
</div>
<a id="a98ea3037c9f5ee73dae8cd6b6f4cd5e5" name="a98ea3037c9f5ee73dae8cd6b6f4cd5e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98ea3037c9f5ee73dae8cd6b6f4cd5e5">&#9670;&#160;</a></span>readData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t E07_400MM::readData </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read received packet data. </p>
<p>Overrides RadioLib's <a class="el" href="class_e07__400_m_m.html#a98ea3037c9f5ee73dae8cd6b6f4cd5e5" title="Read received packet data.">readData()</a> to use BURST mode for all FIFO operations. Reads packet data, RSSI, and LQI in correct sequence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Buffer to store received data </td></tr>
    <tr><td class="paramname">len</td><td>Maximum length to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code (RADIOLIB_ERR_NONE on success) </dd></dl>

<p>Reimplemented from <a class="el" href="class_c_c1101.html#a8c79975a7bbe8a37f8214ecd1f69ba22">CC1101</a>.</p>

</div>
</div>
<a id="a26d97adc5d08ee1391b81fe0f18a8e68" name="a26d97adc5d08ee1391b81fe0f18a8e68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26d97adc5d08ee1391b81fe0f18a8e68">&#9670;&#160;</a></span>scanRSSI()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t E07_400MM::scanRSSI </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>rssi_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>center_freq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>step_khz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dwell_time_us</em> = <code>3000</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform optimized RSSI spectrum scan. </p>
<p>New method specific to E07-400MM for high-performance spectrum scanning. Uses direct register access with microsecond-precision delays.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rssi_values</td><td>Array to store RSSI values (must be pre-allocated) </td></tr>
    <tr><td class="paramname">num_points</td><td>Number of frequency points to scan </td></tr>
    <tr><td class="paramname">center_freq</td><td>Center frequency in MHz </td></tr>
    <tr><td class="paramname">step_khz</td><td>Frequency step in kHz </td></tr>
    <tr><td class="paramname">dwell_time_us</td><td>Dwell time per frequency in microseconds (default: 3000s = 3ms) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code (RADIOLIB_ERR_NONE on success) </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/modules/E07400MM/<a class="el" href="_e07400_m_m_8h_source.html">E07400MM.h</a></li>
<li>src/modules/E07400MM/<a class="el" href="_e07400_m_m_8cpp.html">E07400MM.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_e07__400_m_m.html">E07_400MM</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
